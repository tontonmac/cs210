/**
 * Huffman coding tree implementation
 * the main method is a test case
 * @author Bob Wilson
 * @version January 19, 2010
 */

import java.util.*;

public class HuffmanTree
{
  private HashMap<Character, String> encodeTable;
  private HashMap<String, Character> decodeTable;
  private double compressionRatio;
  
  public HuffmanTree(String message)
  {
    // Build a map of characters to their frequencies in the message text
    // Create a HuffmanNode for each character to eventually build tree
    HashMap<Character,HuffmanNode> map = new HashMap<Character,HuffmanNode>();          
    String s = message;
    for(int i = 0; i < s.length(); i++)
    {
      char c = s.charAt(i);
      
      HuffmanNode v = map.get(new Character(c));
      
      if(v == null)
      {
        map.put(c, v );
      }
      else
      { 
        HuffmanNode x = new HuffmanNode(c, 1, v, v);
        x.increment();
        map.put(c, x);
        
        System.out.println(map);
      }
    }
  
  
  
  // Create a PriorityQueue to "sort" the HuffmanNode objects.
  // Iterate over a set of Map.Entry objects from the frequency
  // map and put each HuffManNode object into the priority queue
  
  
  
  
  
  // Combine the two lowest frequency nodes until there is only one node left
  // The last node left in the queue will be the root of the Huffman code tree
  
  
  
  
  
  // Build HashMaps for the encode and decode tables
  
  
  
}

// recursive method to perform a post order traversal of the Huffman code tree
// and build encode and decode tables as reverse mappings of each other

private void buildTables(HuffmanNode node, String code)
{
  
  
  
  
}

// Use the encode table to encode the message character by character
// and calculate the compression ratio for this message

public String encode(String message)
{
  
  
  
  
  
}

// Identify code sequences in the encoded message and
// use the decode table to decode each code sequence

public String decode(String encodedMessage)
{
  
  
  
  
  
}

// provide the compression ratio for the most recent message encoding
// should be called immediately after encoding the message to get valid data

public double getCompressionRatio()
{
  
  
  
  
}

// A test case for this class

public static void main(String [] args)
{
  String message = "The quick brown fox jumps over the lazy dog's back 1234567890 times."; 
  message = "Now is the time for all good men to come to the aid of their country.";
  HuffmanTree myTree = new HuffmanTree(message);
  System.out.println("Message is: " + message);
  String encodedMessage = myTree.encode(message);
  System.out.println("Encoded as:\n" + encodedMessage);
  System.out.println("Compression Ratio: " + myTree.getCompressionRatio() + " to 1");
  System.out.println("Decoded as: " + myTree.decode(encodedMessage));
}
}